// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: predictions.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createForecast = `-- name: CreateForecast :one

INSERT INTO pred.forecasts(
    source_type_id, location_id, model_id, init_time_utc
) VALUES (
    (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2), $1, $3, $4
) RETURNING forecast_id, init_time_utc, source_type_id, location_id, model_id
`

type CreateForecastParams struct {
	LocationID     int32
	SourceTypeName string
	ModelID        int32
	InitTimeUtc    pgtype.Timestamp
}

type CreateForecastRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	ModelID      int32
}

// --- Forecasts ---
func (q *Queries) CreateForecast(ctx context.Context, arg CreateForecastParams) (CreateForecastRow, error) {
	row := q.db.QueryRow(ctx, createForecast,
		arg.LocationID,
		arg.SourceTypeName,
		arg.ModelID,
		arg.InitTimeUtc,
	)
	var i CreateForecastRow
	err := row.Scan(
		&i.ForecastID,
		&i.InitTimeUtc,
		&i.SourceTypeID,
		&i.LocationID,
		&i.ModelID,
	)
	return i, err
}

const createModel = `-- name: CreateModel :one

INSERT INTO pred.models (model_name, model_version) VALUES (
    $1, $2
) RETURNING model_id
`

type CreateModelParams struct {
	ModelName    string
	ModelVersion string
}

// --- Models ---
func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (int32, error) {
	row := q.db.QueryRow(ctx, createModel, arg.ModelName, arg.ModelVersion)
	var model_id int32
	err := row.Scan(&model_id)
	return model_id, err
}

type CreatePredictionsAsInt16UsingCopyParams struct {
	HorizonMins   int16
	P10           *int16
	P50           int16
	P90           *int16
	ForecastID    int32
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

const getDefaultModel = `-- name: GetDefaultModel :one
SELECT
    model_id, model_name, model_version, created_at_utc
FROM pred.models
WHERE is_default = true
LIMIT 1
`

type GetDefaultModelRow struct {
	ModelID      int32
	ModelName    string
	ModelVersion string
	CreatedAtUtc pgtype.Timestamp
}

func (q *Queries) GetDefaultModel(ctx context.Context) (GetDefaultModelRow, error) {
	row := q.db.QueryRow(ctx, getDefaultModel)
	var i GetDefaultModelRow
	err := row.Scan(
		&i.ModelID,
		&i.ModelName,
		&i.ModelVersion,
		&i.CreatedAtUtc,
	)
	return i, err
}

const getForecast = `-- name: GetForecast :one
SELECT
    f.forecast_id,
    f.init_time_utc,
    f.source_type_id,
    f.location_id,
    f.model_id
FROM pred.forecasts f
WHERE f.location_id = $1
AND f.source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
AND f.model_id = $3
AND f.init_time_utc = $4
`

type GetForecastParams struct {
	LocationID     int32
	SourceTypeName string
	ModelID        int32
	InitTimeUtc    pgtype.Timestamp
}

type GetForecastRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	ModelID      int32
}

func (q *Queries) GetForecast(ctx context.Context, arg GetForecastParams) (GetForecastRow, error) {
	row := q.db.QueryRow(ctx, getForecast,
		arg.LocationID,
		arg.SourceTypeName,
		arg.ModelID,
		arg.InitTimeUtc,
	)
	var i GetForecastRow
	err := row.Scan(
		&i.ForecastID,
		&i.InitTimeUtc,
		&i.SourceTypeID,
		&i.LocationID,
		&i.ModelID,
	)
	return i, err
}

const getForecastsTimeComponent = `-- name: GetForecastsTimeComponent :many
WITH desired_init_times AS (
    SELECT 
        (d.day::date + make_time(sqlq.arg(hour)::integer, $4::integer, 0))::timestamp AS init_time_utc 
    FROM generate_series(
        NOW() - INTERVAL '7 days',
        NOW() - INTERVAL '1 day',
        INTERVAL '1 day'
    ) AS d(day)
    ORDER BY d.day ASC
)
SELECT
    f.forecast_id,
    f.init_time_utc,
    f.source_type_id,
    f.location_id,
    f.model_id
FROM pred.forecasts f
INNER JOIN desired_init_times dit ON f.init_time_utc = dit.init_time_utc
WHERE f.location_id = $1
AND f.source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
AND f.model_id = $3
`

type GetForecastsTimeComponentParams struct {
	LocationID     int32
	SourceTypeName string
	ModelID        int32
	Minute         int32
}

type GetForecastsTimeComponentRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	ModelID      int32
}

func (q *Queries) GetForecastsTimeComponent(ctx context.Context, arg GetForecastsTimeComponentParams) ([]GetForecastsTimeComponentRow, error) {
	rows, err := q.db.Query(ctx, getForecastsTimeComponent,
		arg.LocationID,
		arg.SourceTypeName,
		arg.ModelID,
		arg.Minute,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetForecastsTimeComponentRow{}
	for rows.Next() {
		var i GetForecastsTimeComponentRow
		if err := rows.Scan(
			&i.ForecastID,
			&i.InitTimeUtc,
			&i.SourceTypeID,
			&i.LocationID,
			&i.ModelID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestForecastAtHorizon = `-- name: GetLatestForecastAtHorizon :one
SELECT
    f.forecast_id,
    f.init_time_utc,
    f.source_type_id,
    f.location_id,
    f.model_id
FROM pred.forecasts f
WHERE f.location_id = $1
AND f.source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
AND f.model_id = $3
AND f.init_time_utc <= $4::timestamp - MAKE_INTERVAL(mins => $5::integer)
ORDER BY f.init_time_utc DESC
LIMIT 1
`

type GetLatestForecastAtHorizonParams struct {
	LocationID     int32
	SourceTypeName string
	ModelID        int32
	PivotTimestamp pgtype.Timestamp
	HorizonMins    int32
}

type GetLatestForecastAtHorizonRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	ModelID      int32
}

// GetLatestForecastAtHorizon retrieves the latest forecast for a given location,
// source type, and model. Only forecasts that are older than the specified horizon
// are considered.
func (q *Queries) GetLatestForecastAtHorizon(ctx context.Context, arg GetLatestForecastAtHorizonParams) (GetLatestForecastAtHorizonRow, error) {
	row := q.db.QueryRow(ctx, getLatestForecastAtHorizon,
		arg.LocationID,
		arg.SourceTypeName,
		arg.ModelID,
		arg.PivotTimestamp,
		arg.HorizonMins,
	)
	var i GetLatestForecastAtHorizonRow
	err := row.Scan(
		&i.ForecastID,
		&i.InitTimeUtc,
		&i.SourceTypeID,
		&i.LocationID,
		&i.ModelID,
	)
	return i, err
}

const getLatestModelByName = `-- name: GetLatestModelByName :one
SELECT
    model_id, model_name, model_version, created_at_utc
FROM pred.models
WHERE model_name = $1
ORDER BY created_at_utc DESC
LIMIT 1
`

type GetLatestModelByNameRow struct {
	ModelID      int32
	ModelName    string
	ModelVersion string
	CreatedAtUtc pgtype.Timestamp
}

func (q *Queries) GetLatestModelByName(ctx context.Context, modelName string) (GetLatestModelByNameRow, error) {
	row := q.db.QueryRow(ctx, getLatestModelByName, modelName)
	var i GetLatestModelByNameRow
	err := row.Scan(
		&i.ModelID,
		&i.ModelName,
		&i.ModelVersion,
		&i.CreatedAtUtc,
	)
	return i, err
}

const getModelById = `-- name: GetModelById :one
SELECT
    model_id, model_name, model_version, created_at_utc
FROM pred.models
WHERE model_id = $1
`

type GetModelByIdRow struct {
	ModelID      int32
	ModelName    string
	ModelVersion string
	CreatedAtUtc pgtype.Timestamp
}

func (q *Queries) GetModelById(ctx context.Context, modelID int32) (GetModelByIdRow, error) {
	row := q.db.QueryRow(ctx, getModelById, modelID)
	var i GetModelByIdRow
	err := row.Scan(
		&i.ModelID,
		&i.ModelName,
		&i.ModelVersion,
		&i.CreatedAtUtc,
	)
	return i, err
}

const getPredictionsAsInt16ByForecastID = `-- name: GetPredictionsAsInt16ByForecastID :many
SELECT
    horizon_mins,
    p10 AS p10_int16,
    p50 AS p50_int16,
    p90 AS p90_int16,
    target_time_utc,
    metadata
FROM pred.predicted_generation_values
WHERE forecast_id = $1
`

type GetPredictionsAsInt16ByForecastIDRow struct {
	HorizonMins   int16
	P10Int16      *int16
	P50Int16      int16
	P90Int16      *int16
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

// GetPredictionsAsInt16ByForecastID retrieves predicted generation values as 16-bit integers,
// with 0 representing 0% and 30000 representing 100% of capacity.
func (q *Queries) GetPredictionsAsInt16ByForecastID(ctx context.Context, forecastID int32) ([]GetPredictionsAsInt16ByForecastIDRow, error) {
	rows, err := q.db.Query(ctx, getPredictionsAsInt16ByForecastID, forecastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionsAsInt16ByForecastIDRow{}
	for rows.Next() {
		var i GetPredictionsAsInt16ByForecastIDRow
		if err := rows.Scan(
			&i.HorizonMins,
			&i.P10Int16,
			&i.P50Int16,
			&i.P90Int16,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionsAsPercentAtTimeAndHorizonForLocations = `-- name: GetPredictionsAsPercentAtTimeAndHorizonForLocations :many
WITH relevant_forecasts AS (
    SELECT
        f.forecast_id,
        f.location_id,
        f.init_time_utc,
        ROW_NUMBER() OVER (PARTITION BY f.location_id ORDER BY f.init_time_utc DESC) AS rn
    FROM pred.forecasts f
    WHERE f.location_id = ANY($4::integer[])
    AND f.source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $1)
    AND f.model_id = $2
    AND f.init_time_utc <= $5::timestamp - MAKE_INTERVAL(mins => $3::integer)
),
latest_relevant_forecasts AS (
    SELECT
        rf.forecast_id,
        rf.location_id,
        rf.init_time_utc
    FROM relevant_forecasts rf
    WHERE rf.rn = 1
)
SELECT
    rf.location_id,
    pgv.horizon_mins,
    decode_smallint(pgv.p10) AS p10_pct,
    decode_smallint(pgv.p50) AS p50_pct,
    decode_smallint(pgv.p90) AS p90_pct,
    pgv.target_time_utc,
    pgv.metadata
FROM pred.predicted_generation_values pgv
INNER JOIN latest_relevant_forecasts rf USING (forecast_id)
WHERE pgv.horizon_mins = $3::integer
`

type GetPredictionsAsPercentAtTimeAndHorizonForLocationsParams struct {
	SourceTypeName string
	ModelID        int32
	HorizonMins    int32
	LocationIds    []int32
	Time           pgtype.Timestamp
}

type GetPredictionsAsPercentAtTimeAndHorizonForLocationsRow struct {
	LocationID    int32
	HorizonMins   int16
	P10Pct        float32
	P50Pct        float32
	P90Pct        float32
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

// GetPredictionsAsPercentAtTimeAndHorizonForLocations retrieves predicted generation values as percentages
// of capacity for a specific time and horizon. This is useful for comparing predictions across multiple locations.
func (q *Queries) GetPredictionsAsPercentAtTimeAndHorizonForLocations(ctx context.Context, arg GetPredictionsAsPercentAtTimeAndHorizonForLocationsParams) ([]GetPredictionsAsPercentAtTimeAndHorizonForLocationsRow, error) {
	rows, err := q.db.Query(ctx, getPredictionsAsPercentAtTimeAndHorizonForLocations,
		arg.SourceTypeName,
		arg.ModelID,
		arg.HorizonMins,
		arg.LocationIds,
		arg.Time,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionsAsPercentAtTimeAndHorizonForLocationsRow{}
	for rows.Next() {
		var i GetPredictionsAsPercentAtTimeAndHorizonForLocationsRow
		if err := rows.Scan(
			&i.LocationID,
			&i.HorizonMins,
			&i.P10Pct,
			&i.P50Pct,
			&i.P90Pct,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionsAsPercentByForecastID = `-- name: GetPredictionsAsPercentByForecastID :many
SELECT
    horizon_mins,
    decode_smallint(p10) AS p10_pct,
    decode_smallint(p50) AS p50_pct,
    decode_smallint(p90) AS p90_pct,
    target_time_utc,
    metadata
FROM pred.predicted_generation_values
WHERE forecast_id = $1
`

type GetPredictionsAsPercentByForecastIDRow struct {
	HorizonMins   int16
	P10Pct        float32
	P50Pct        float32
	P90Pct        float32
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

// GetPredictionsAsPercentByForecastID retrieves predicted generation values as percentages of
// capacity for a specific forecast ID. This is slower than returning the values directly,
// so use where readability or understandability is more important than performance.
func (q *Queries) GetPredictionsAsPercentByForecastID(ctx context.Context, forecastID int32) ([]GetPredictionsAsPercentByForecastIDRow, error) {
	rows, err := q.db.Query(ctx, getPredictionsAsPercentByForecastID, forecastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionsAsPercentByForecastIDRow{}
	for rows.Next() {
		var i GetPredictionsAsPercentByForecastIDRow
		if err := rows.Scan(
			&i.HorizonMins,
			&i.P10Pct,
			&i.P50Pct,
			&i.P90Pct,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionsTimeseriesAsPercentAtHorizon = `-- name: GetPredictionsTimeseriesAsPercentAtHorizon :many
WITH relevant_forecasts AS (
    -- Get all the forecasts that fall within the time window for the given location, source, and model
    SELECT
        f.forecast_id
    FROM pred.forecasts f
    WHERE f.location_id = $1
    AND f.source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    AND f.model_id = $3
    AND f.init_time_utc >= $4::timestamp - MAKE_INTERVAL(
        mins => $5::integer, hours => 36
    )
),
filteredPredictions AS (
    -- Get all the predicted generation values for the relevant forecasts who's horizon is greater than
    -- or equal to the specified horizon_mins
    SELECT
        pv.horizon_mins,
        pv.p10,
        pv.p50,
        pv.p90,
        pv.target_time_utc,
        pv.metadata
    FROM pred.predicted_generation_values pv
    INNER JOIN relevant_forecasts rf USING (forecast_id)
    WHERE pv.target_time_utc >= $4::timestamp - MAKE_INTERVAL(mins => $5::integer, hours => 36)
    AND pv.horizon_mins >= $5::integer
),
rankedPredictions AS (
    -- Rank the predictions by horizon_mins for each target_time_utc
    SELECT
        horizon_mins, p10, p50, p90, target_time_utc, metadata,
        ROW_NUMBER() OVER (PARTITION BY target_time_utc ORDER BY horizon_mins ASC) AS rn
    FROM filteredPredictions
)
SELECT
    -- For each target time, choose the value with the lowest available horizon
    rp.horizon_mins,
    decode_smallint(p10) AS p10_pct,
    decode_smallint(p50) AS p50_pct,
    decode_smallint(p90) AS p90_pct,
    rp.target_time_utc,
    rp.metadata
FROM rankedPredictions rp
WHERE rp.rn = 1
ORDER BY rp.target_time_utc ASC
`

type GetPredictionsTimeseriesAsPercentAtHorizonParams struct {
	LocationID     int32
	SourceTypeName string
	ModelID        int32
	PivotTimestamp pgtype.Timestamp
	HorizonMins    int32
}

type GetPredictionsTimeseriesAsPercentAtHorizonRow struct {
	HorizonMins   int16
	P10Pct        float32
	P50Pct        float32
	P90Pct        float32
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

// GetPredictionsTimeseriesAsPercentAtHorizon retrieves predicted generation values as a timeseries.
// Multiple forecasts make up the timeseries, so overlapping predictions are filtered
// according to the lowest allowable horizon. The timeseries window is 36 hours ago to now.
// Yields are returned as percentages of capacity.
// Has been measured to be 10 times slower than returning the values directly, so use in non-critical paths
// where readability or understandability is more important than performance.
func (q *Queries) GetPredictionsTimeseriesAsPercentAtHorizon(ctx context.Context, arg GetPredictionsTimeseriesAsPercentAtHorizonParams) ([]GetPredictionsTimeseriesAsPercentAtHorizonRow, error) {
	rows, err := q.db.Query(ctx, getPredictionsTimeseriesAsPercentAtHorizon,
		arg.LocationID,
		arg.SourceTypeName,
		arg.ModelID,
		arg.PivotTimestamp,
		arg.HorizonMins,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPredictionsTimeseriesAsPercentAtHorizonRow{}
	for rows.Next() {
		var i GetPredictionsTimeseriesAsPercentAtHorizonRow
		if err := rows.Scan(
			&i.HorizonMins,
			&i.P10Pct,
			&i.P50Pct,
			&i.P90Pct,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModels = `-- name: ListModels :many
SELECT
    model_id, model_name, model_version, created_at_utc
FROM pred.models
ORDER BY created_at_utc DESC
`

type ListModelsRow struct {
	ModelID      int32
	ModelName    string
	ModelVersion string
	CreatedAtUtc pgtype.Timestamp
}

func (q *Queries) ListModels(ctx context.Context) ([]ListModelsRow, error) {
	rows, err := q.db.Query(ctx, listModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListModelsRow{}
	for rows.Next() {
		var i ListModelsRow
		if err := rows.Scan(
			&i.ModelID,
			&i.ModelName,
			&i.ModelVersion,
			&i.CreatedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultModel = `-- name: SetDefaultModel :exec
UPDATE pred.models AS m SET
    is_default = c.new_is_default
FROM (VALUES
    ((SELECT model_id FROM pred.models WHERE is_default = true), NULL), ($1::integer, true)
) AS c(model_id, new_is_default)
WHERE m.model_id = c.model_id
`

func (q *Queries) SetDefaultModel(ctx context.Context, modelID int32) error {
	_, err := q.db.Exec(ctx, setDefaultModel, modelID)
	return err
}
