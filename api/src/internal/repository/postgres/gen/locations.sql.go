// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocation = `-- name: CreateLocation :one
INSERT INTO loc.locations AS l (
    location_name, geom, location_type_id 
) VALUES (
    UPPER($2::text),
    ST_GeomFromText($3::text, 4326), --Ensure in WSG84
    (SELECT location_type_id FROM loc.location_types AS lt WHERE lt.location_type_name = $1)
) RETURNING l.location_id, l.location_name
`

type CreateLocationParams struct {
	LocationTypeName string
	LocationName     string
	Geom             string
}

type CreateLocationRow struct {
	LocationID   int32
	LocationName string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (CreateLocationRow, error) {
	row := q.db.QueryRow(ctx, createLocation, arg.LocationTypeName, arg.LocationName, arg.Geom)
	var i CreateLocationRow
	err := row.Scan(&i.LocationID, &i.LocationName)
	return i, err
}

const createLocationSource = `-- name: CreateLocationSource :one
INSERT INTO loc.location_sources (
    location_id, source_type_id, capacity,
    capacity_unit_prefix_factor, metadata
) SELECT 
    $1,
    (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2),
    e.value,
    e.exponent,
    $3::jsonb
FROM
    loc.encode_kw($4::bigint) AS e
RETURNING record_id, capacity, capacity_unit_prefix_factor
`

type CreateLocationSourceParams struct {
	LocationID     int32
	SourceTypeName string
	Metadata       []byte
	CapacityKw     int64
}

type CreateLocationSourceRow struct {
	RecordID                 int32
	Capacity                 int16
	CapacityUnitPrefixFactor int16
}

func (q *Queries) CreateLocationSource(ctx context.Context, arg CreateLocationSourceParams) (CreateLocationSourceRow, error) {
	row := q.db.QueryRow(ctx, createLocationSource,
		arg.LocationID,
		arg.SourceTypeName,
		arg.Metadata,
		arg.CapacityKw,
	)
	var i CreateLocationSourceRow
	err := row.Scan(&i.RecordID, &i.Capacity, &i.CapacityUnitPrefixFactor)
	return i, err
}

const decomissionLocationSource = `-- name: DecomissionLocationSource :exec
DELETE FROM loc.location_sources
WHERE 
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    AND UPPER(sys_period) IS NULL
`

type DecomissionLocationSourceParams struct {
	LocationID     int32
	SourceTypeName string
}

func (q *Queries) DecomissionLocationSource(ctx context.Context, arg DecomissionLocationSourceParams) error {
	_, err := q.db.Exec(ctx, decomissionLocationSource, arg.LocationID, arg.SourceTypeName)
	return err
}

const getLocationById = `-- name: GetLocationById :one
SELECT 
    l.location_id,
    l.location_name,
    ST_AsText(l.geom)::text AS geom,
    (SELECT location_type_name FROM loc.location_types WHERE location_type_id = l.location_type_id) AS location_type_name,
    ST_Y(l.centroid)::real AS latitude,
    ST_X(l.centroid)::real AS longitude
FROM loc.locations AS l
WHERE l.location_id = $1
`

type GetLocationByIdRow struct {
	LocationID       int32
	LocationName     string
	Geom             string
	LocationTypeName string
	Latitude         float32
	Longitude        float32
}

func (q *Queries) GetLocationById(ctx context.Context, locationID int32) (GetLocationByIdRow, error) {
	row := q.db.QueryRow(ctx, getLocationById, locationID)
	var i GetLocationByIdRow
	err := row.Scan(
		&i.LocationID,
		&i.LocationName,
		&i.Geom,
		&i.LocationTypeName,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const getLocationGeoJSONByIds = `-- name: GetLocationGeoJSONByIds :one
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(
        ST_AsGeoJSON(sl.*, id_column => 'location_id'::text, geom_column => 'geom_simple')::jsonb
    )
) AS geojson
FROM (
    SELECT 
        l.location_id,
        l.location_name,
        (SELECT location_type_name FROM loc.location_types WHERE location_type_id = l.location_type_id) AS location_type_name,
        ST_SimplifyPreserveTopology(l.geom, $1::real) AS geom_simple
    FROM loc.locations AS l
    WHERE l.location_id = ANY($2::int[])
) AS sl
`

type GetLocationGeoJSONByIdsParams struct {
	SimplificationLevel float32
	LocationIds         []int32
}

func (q *Queries) GetLocationGeoJSONByIds(ctx context.Context, arg GetLocationGeoJSONByIdsParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getLocationGeoJSONByIds, arg.SimplificationLevel, arg.LocationIds)
	var geojson []byte
	err := row.Scan(&geojson)
	return geojson, err
}

const getLocationSource = `-- name: GetLocationSource :one
/*- Queries for the location_sources table ---------------------------
*/

SELECT 
    record_id,
    (capacity::bigint * POWER(10::bigint, capacity_unit_prefix_factor - 3))::bigint AS capacity_kw,
    metadata
FROM loc.location_sources
WHERE 
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    AND UPPER(sys_period) IS NULL
`

type GetLocationSourceParams struct {
	LocationID     int32
	SourceTypeName string
}

type GetLocationSourceRow struct {
	RecordID   int32
	CapacityKw int64
	Metadata   []byte
}

// Get latest active record via the UPPER(sys_period) IS NULL condition
func (q *Queries) GetLocationSource(ctx context.Context, arg GetLocationSourceParams) (GetLocationSourceRow, error) {
	row := q.db.QueryRow(ctx, getLocationSource, arg.LocationID, arg.SourceTypeName)
	var i GetLocationSourceRow
	err := row.Scan(&i.RecordID, &i.CapacityKw, &i.Metadata)
	return i, err
}

const getSourceTypeByName = `-- name: GetSourceTypeByName :one
SELECT 
    source_type_id, source_type_name
FROM loc.source_types
WHERE source_type_name = $1
`

func (q *Queries) GetSourceTypeByName(ctx context.Context, sourceTypeName string) (LocSourceType, error) {
	row := q.db.QueryRow(ctx, getSourceTypeByName, sourceTypeName)
	var i LocSourceType
	err := row.Scan(&i.SourceTypeID, &i.SourceTypeName)
	return i, err
}

const listLocationGeometryByType = `-- name: ListLocationGeometryByType :many
SELECT
    location_name, ST_AsText(geom)
FROM loc.locations AS l
WHERE
    l.location_type_id = (SELECT location_type_id FROM loc.location_types WHERE location_type_name = $1)
`

type ListLocationGeometryByTypeRow struct {
	LocationName string
	StAstext     interface{}
}

func (q *Queries) ListLocationGeometryByType(ctx context.Context, locationTypeName string) ([]ListLocationGeometryByTypeRow, error) {
	rows, err := q.db.Query(ctx, listLocationGeometryByType, locationTypeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationGeometryByTypeRow{}
	for rows.Next() {
		var i ListLocationGeometryByTypeRow
		if err := rows.Scan(&i.LocationName, &i.StAstext); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationIdsByType = `-- name: ListLocationIdsByType :many
SELECT
    location_id, location_name
FROM loc.locations AS l
WHERE
    l.location_type_id = (SELECT location_type_id FROM loc.location_types WHERE location_type_name = $1)
ORDER BY l.location_id
`

type ListLocationIdsByTypeRow struct {
	LocationID   int32
	LocationName string
}

func (q *Queries) ListLocationIdsByType(ctx context.Context, locationTypeName string) ([]ListLocationIdsByTypeRow, error) {
	rows, err := q.db.Query(ctx, listLocationIdsByType, locationTypeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationIdsByTypeRow{}
	for rows.Next() {
		var i ListLocationIdsByTypeRow
		if err := rows.Scan(&i.LocationID, &i.LocationName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationSourceCapacityHistory = `-- name: ListLocationSourceCapacityHistory :many
SELECT
    (capacity::bigint * POWER(10::bigint, capacity_unit_prefix_factor - 3))::bigint AS capacity_kw,
    LOWER(sys_period) AS valid_from
FROM loc.location_sources
WHERE
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    ORDER BY LOWER(sys_period) ASC
`

type ListLocationSourceCapacityHistoryParams struct {
	LocationID     int32
	SourceTypeName string
}

type ListLocationSourceCapacityHistoryRow struct {
	CapacityKw int64
	ValidFrom  string
}

func (q *Queries) ListLocationSourceCapacityHistory(ctx context.Context, arg ListLocationSourceCapacityHistoryParams) ([]ListLocationSourceCapacityHistoryRow, error) {
	rows, err := q.db.Query(ctx, listLocationSourceCapacityHistory, arg.LocationID, arg.SourceTypeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationSourceCapacityHistoryRow{}
	for rows.Next() {
		var i ListLocationSourceCapacityHistoryRow
		if err := rows.Scan(&i.CapacityKw, &i.ValidFrom); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationSourceHistory = `-- name: ListLocationSourceHistory :many
SELECT
    record_id,
    (capacity::bigint * POWER(10::bigint, capacity_unit_prefix_factor - 3))::bigint AS capacity_kw,
    metadata, sys_period
FROM loc.location_sources
WHERE 
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    ORDER BY LOWER(sys_period) DESC
`

type ListLocationSourceHistoryParams struct {
	LocationID     int32
	SourceTypeName string
}

type ListLocationSourceHistoryRow struct {
	RecordID   int32
	CapacityKw int64
	Metadata   []byte
	SysPeriod  pgtype.Range[pgtype.Timestamp]
}

func (q *Queries) ListLocationSourceHistory(ctx context.Context, arg ListLocationSourceHistoryParams) ([]ListLocationSourceHistoryRow, error) {
	rows, err := q.db.Query(ctx, listLocationSourceHistory, arg.LocationID, arg.SourceTypeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationSourceHistoryRow{}
	for rows.Next() {
		var i ListLocationSourceHistoryRow
		if err := rows.Scan(
			&i.RecordID,
			&i.CapacityKw,
			&i.Metadata,
			&i.SysPeriod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsByType = `-- name: ListLocationsByType :many
SELECT
    location_id, location_name, geom, location_type_id, centroid, geom_hash
FROM loc.locations AS l
WHERE
    l.location_type_id = (SELECT location_type_id FROM loc.location_types WHERE location_type_name = $1)
ORDER BY l.location_id
`

func (q *Queries) ListLocationsByType(ctx context.Context, locationTypeName string) ([]LocLocation, error) {
	rows, err := q.db.Query(ctx, listLocationsByType, locationTypeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocLocation{}
	for rows.Next() {
		var i LocLocation
		if err := rows.Scan(
			&i.LocationID,
			&i.LocationName,
			&i.Geom,
			&i.LocationTypeID,
			&i.Centroid,
			&i.GeomHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourceTypes = `-- name: ListSourceTypes :many

SELECT 
    source_type_id, source_type_name
FROM loc.source_types
`

// - Queries for the locations table ------------------------------
func (q *Queries) ListSourceTypes(ctx context.Context) ([]LocSourceType, error) {
	rows, err := q.db.Query(ctx, listSourceTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocSourceType{}
	for rows.Next() {
		var i LocSourceType
		if err := rows.Scan(&i.SourceTypeID, &i.SourceTypeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocationSourceCapacity = `-- name: UpdateLocationSourceCapacity :exec
UPDATE loc.location_sources SET
    capacity = e.value,
    capacity_unit_prefix_factor = e.exponent
FROM
    loc.encode_kw($3::bigint) AS e
WHERE 
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    AND UPPER(sys_period) IS NULL
`

type UpdateLocationSourceCapacityParams struct {
	LocationID     int32
	SourceTypeName string
	CapacityKw     int64
}

func (q *Queries) UpdateLocationSourceCapacity(ctx context.Context, arg UpdateLocationSourceCapacityParams) error {
	_, err := q.db.Exec(ctx, updateLocationSourceCapacity, arg.LocationID, arg.SourceTypeName, arg.CapacityKw)
	return err
}

const updateLocationSourceMetadata = `-- name: UpdateLocationSourceMetadata :exec
UPDATE loc.location_sources SET
    metadata = $3
WHERE 
    location_id = $1
    AND source_type_id = (SELECT source_type_id FROM loc.source_types WHERE source_type_name = $2)
    AND UPPER(sys_period) IS NULL
`

type UpdateLocationSourceMetadataParams struct {
	LocationID     int32
	SourceTypeName string
	Metadata       []byte
}

func (q *Queries) UpdateLocationSourceMetadata(ctx context.Context, arg UpdateLocationSourceMetadataParams) error {
	_, err := q.db.Exec(ctx, updateLocationSourceMetadata, arg.LocationID, arg.SourceTypeName, arg.Metadata)
	return err
}
