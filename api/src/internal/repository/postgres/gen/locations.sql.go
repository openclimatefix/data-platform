// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: locations.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocationRegion = `-- name: CreateLocationRegion :one
WITH new_loc_id AS (
    INSERT INTO loc.locations (
        name, latitude, longitude, capacity, capacity_unit_prefix_factor
    ) VALUES (
        $1, $2, $3, $4, $5
    ) RETURNING location_id
)
INSERT INTO loc.region_metadata (
    location_id, region_name, boundary_geojson
) VALUES (
    new_loc_id, $6, $7
) RETURNING location_id
`

type CreateLocationRegionParams struct {
	Name                     string
	Latitude                 float32
	Longitude                float32
	Capacity                 int16
	CapacityUnitPrefixFactor int16
	RegionName               string
	BoundaryGeojson          []byte
}

func (q *Queries) CreateLocationRegion(ctx context.Context, arg CreateLocationRegionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLocationRegion,
		arg.Name,
		arg.Latitude,
		arg.Longitude,
		arg.Capacity,
		arg.CapacityUnitPrefixFactor,
		arg.RegionName,
		arg.BoundaryGeojson,
	)
	var location_id int32
	err := row.Scan(&location_id)
	return location_id, err
}

const createLocationSite = `-- name: CreateLocationSite :one
WITH new_loc_id AS (
    INSERT INTO loc.locations (
        name, latitude, longitude, capacity, capicity_unit_prefix_factor
    ) VALUES (
        $1, $2, $3, $4, $5
    ) RETURNING location_id
)
INSERT INTO loc.site_metadata (
    location_id, client_name, client_site_id, yaw_degrees, pitch_degrees, energy_source
) VALUES (
    new_loc_id, $5, $6, $7, $8, $9
) RETURNING location_id
`

type CreateLocationSiteParams struct {
	Name         string
	Latitude     float32
	Longitude    float32
	Capacity     int16
	ClientName   string
	ClientSiteID string
	YawDegrees   *int16
	PitchDegrees *int16
	EnergySource int16
}

func (q *Queries) CreateLocationSite(ctx context.Context, arg CreateLocationSiteParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLocationSite,
		arg.Name,
		arg.Latitude,
		arg.Longitude,
		arg.Capacity,
		arg.ClientName,
		arg.ClientSiteID,
		arg.YawDegrees,
		arg.PitchDegrees,
		arg.EnergySource,
	)
	var location_id int32
	err := row.Scan(&location_id)
	return location_id, err
}

const listLocations = `-- name: ListLocations :many
SELECT location_id, name, latitude, longitude, capacity, capacity_unit_prefix_factor, sys_period FROM loc.locations
ORDER BY location_id
`

func (q *Queries) ListLocations(ctx context.Context) ([]LocLocation, error) {
	rows, err := q.db.Query(ctx, listLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocLocation{}
	for rows.Next() {
		var i LocLocation
		if err := rows.Scan(
			&i.LocationID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
			&i.Capacity,
			&i.CapacityUnitPrefixFactor,
			&i.SysPeriod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegions = `-- name: ListRegions :many
SELECT l.location_id, name, latitude, longitude, capacity, capacity_unit_prefix_factor, sys_period, region_metadata.location_id, region_name, boundary_geojson FROM loc.locations as l
LEFT OUTER JOIN loc.region_metadata USING (location_id)
ORDER BY l.location_id
`

type ListRegionsRow struct {
	LocationID               int32
	Name                     string
	Latitude                 float32
	Longitude                float32
	Capacity                 int16
	CapacityUnitPrefixFactor int16
	SysPeriod                pgtype.Range[pgtype.Timestamptz]
	LocationID_2             *int32
	RegionName               *string
	BoundaryGeojson          []byte
}

func (q *Queries) ListRegions(ctx context.Context) ([]ListRegionsRow, error) {
	rows, err := q.db.Query(ctx, listRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegionsRow{}
	for rows.Next() {
		var i ListRegionsRow
		if err := rows.Scan(
			&i.LocationID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
			&i.Capacity,
			&i.CapacityUnitPrefixFactor,
			&i.SysPeriod,
			&i.LocationID_2,
			&i.RegionName,
			&i.BoundaryGeojson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSites = `-- name: ListSites :many
SELECT l.location_id, name, latitude, longitude, capacity, capacity_unit_prefix_factor, sys_period, site_metadata.location_id, client_name, client_site_id, yaw_degrees, pitch_degrees, energy_source FROM loc.locations as l
LEFT OUTER JOIN loc.site_metadata USING (location_id)
ORDER BY l.location_id
`

type ListSitesRow struct {
	LocationID               int32
	Name                     string
	Latitude                 float32
	Longitude                float32
	Capacity                 int16
	CapacityUnitPrefixFactor int16
	SysPeriod                pgtype.Range[pgtype.Timestamptz]
	LocationID_2             *int32
	ClientName               *string
	ClientSiteID             *string
	YawDegrees               *int16
	PitchDegrees             *int16
	EnergySource             *int16
}

func (q *Queries) ListSites(ctx context.Context) ([]ListSitesRow, error) {
	rows, err := q.db.Query(ctx, listSites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSitesRow{}
	for rows.Next() {
		var i ListSitesRow
		if err := rows.Scan(
			&i.LocationID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
			&i.Capacity,
			&i.CapacityUnitPrefixFactor,
			&i.SysPeriod,
			&i.LocationID_2,
			&i.ClientName,
			&i.ClientSiteID,
			&i.YawDegrees,
			&i.PitchDegrees,
			&i.EnergySource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
