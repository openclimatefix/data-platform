// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.24.4
// source: src/proto/api.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QuartzAPIClient is the client API for QuartzAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuartzAPIClient interface {
	// Get a set of Predicted Yields as a timeseries per location
	GetPredictedTimeseries(ctx context.Context, in *GetPredictedTimeseriesRequest, opts ...grpc.CallOption) (QuartzAPI_GetPredictedTimeseriesClient, error)
	// Get a set of Actual Yields as a timeseries per location
	GetActualTimeseries(ctx context.Context, in *GetActualTimeseriesRequest, opts ...grpc.CallOption) (QuartzAPI_GetActualTimeseriesClient, error)
	// Get the predicted yield for a single timestamp across a set of locations
	GetActualCrossSection(ctx context.Context, in *GetActualCrossSectionRequest, opts ...grpc.CallOption) (*GetActualCrossSectionResponse, error)
	// Get the actual yield for a single timestamp across a set of locations
	GetPredictedCrossSection(ctx context.Context, in *GetPredictedCrossSectionRequest, opts ...grpc.CallOption) (*GetPredictedCrossSectionResponse, error)
	// Get the metadata for a single location
	GetLocationMetadata(ctx context.Context, in *GetLocationMetadataRequest, opts ...grpc.CallOption) (*GetLocationMetadataResponse, error)
}

type quartzAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewQuartzAPIClient(cc grpc.ClientConnInterface) QuartzAPIClient {
	return &quartzAPIClient{cc}
}

func (c *quartzAPIClient) GetPredictedTimeseries(ctx context.Context, in *GetPredictedTimeseriesRequest, opts ...grpc.CallOption) (QuartzAPI_GetPredictedTimeseriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &QuartzAPI_ServiceDesc.Streams[0], "/api.QuartzAPI/GetPredictedTimeseries", opts...)
	if err != nil {
		return nil, err
	}
	x := &quartzAPIGetPredictedTimeseriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QuartzAPI_GetPredictedTimeseriesClient interface {
	Recv() (*GetPredictedTimeseriesResponse, error)
	grpc.ClientStream
}

type quartzAPIGetPredictedTimeseriesClient struct {
	grpc.ClientStream
}

func (x *quartzAPIGetPredictedTimeseriesClient) Recv() (*GetPredictedTimeseriesResponse, error) {
	m := new(GetPredictedTimeseriesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quartzAPIClient) GetActualTimeseries(ctx context.Context, in *GetActualTimeseriesRequest, opts ...grpc.CallOption) (QuartzAPI_GetActualTimeseriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &QuartzAPI_ServiceDesc.Streams[1], "/api.QuartzAPI/GetActualTimeseries", opts...)
	if err != nil {
		return nil, err
	}
	x := &quartzAPIGetActualTimeseriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QuartzAPI_GetActualTimeseriesClient interface {
	Recv() (*GetActualTimeseriesResponse, error)
	grpc.ClientStream
}

type quartzAPIGetActualTimeseriesClient struct {
	grpc.ClientStream
}

func (x *quartzAPIGetActualTimeseriesClient) Recv() (*GetActualTimeseriesResponse, error) {
	m := new(GetActualTimeseriesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quartzAPIClient) GetActualCrossSection(ctx context.Context, in *GetActualCrossSectionRequest, opts ...grpc.CallOption) (*GetActualCrossSectionResponse, error) {
	out := new(GetActualCrossSectionResponse)
	err := c.cc.Invoke(ctx, "/api.QuartzAPI/GetActualCrossSection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quartzAPIClient) GetPredictedCrossSection(ctx context.Context, in *GetPredictedCrossSectionRequest, opts ...grpc.CallOption) (*GetPredictedCrossSectionResponse, error) {
	out := new(GetPredictedCrossSectionResponse)
	err := c.cc.Invoke(ctx, "/api.QuartzAPI/GetPredictedCrossSection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quartzAPIClient) GetLocationMetadata(ctx context.Context, in *GetLocationMetadataRequest, opts ...grpc.CallOption) (*GetLocationMetadataResponse, error) {
	out := new(GetLocationMetadataResponse)
	err := c.cc.Invoke(ctx, "/api.QuartzAPI/GetLocationMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuartzAPIServer is the server API for QuartzAPI service.
// All implementations must embed UnimplementedQuartzAPIServer
// for forward compatibility
type QuartzAPIServer interface {
	// Get a set of Predicted Yields as a timeseries per location
	GetPredictedTimeseries(*GetPredictedTimeseriesRequest, QuartzAPI_GetPredictedTimeseriesServer) error
	// Get a set of Actual Yields as a timeseries per location
	GetActualTimeseries(*GetActualTimeseriesRequest, QuartzAPI_GetActualTimeseriesServer) error
	// Get the predicted yield for a single timestamp across a set of locations
	GetActualCrossSection(context.Context, *GetActualCrossSectionRequest) (*GetActualCrossSectionResponse, error)
	// Get the actual yield for a single timestamp across a set of locations
	GetPredictedCrossSection(context.Context, *GetPredictedCrossSectionRequest) (*GetPredictedCrossSectionResponse, error)
	// Get the metadata for a single location
	GetLocationMetadata(context.Context, *GetLocationMetadataRequest) (*GetLocationMetadataResponse, error)
	mustEmbedUnimplementedQuartzAPIServer()
}

// UnimplementedQuartzAPIServer must be embedded to have forward compatible implementations.
type UnimplementedQuartzAPIServer struct {
}

func (UnimplementedQuartzAPIServer) GetPredictedTimeseries(*GetPredictedTimeseriesRequest, QuartzAPI_GetPredictedTimeseriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPredictedTimeseries not implemented")
}
func (UnimplementedQuartzAPIServer) GetActualTimeseries(*GetActualTimeseriesRequest, QuartzAPI_GetActualTimeseriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetActualTimeseries not implemented")
}
func (UnimplementedQuartzAPIServer) GetActualCrossSection(context.Context, *GetActualCrossSectionRequest) (*GetActualCrossSectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActualCrossSection not implemented")
}
func (UnimplementedQuartzAPIServer) GetPredictedCrossSection(context.Context, *GetPredictedCrossSectionRequest) (*GetPredictedCrossSectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPredictedCrossSection not implemented")
}
func (UnimplementedQuartzAPIServer) GetLocationMetadata(context.Context, *GetLocationMetadataRequest) (*GetLocationMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationMetadata not implemented")
}
func (UnimplementedQuartzAPIServer) mustEmbedUnimplementedQuartzAPIServer() {}

// UnsafeQuartzAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuartzAPIServer will
// result in compilation errors.
type UnsafeQuartzAPIServer interface {
	mustEmbedUnimplementedQuartzAPIServer()
}

func RegisterQuartzAPIServer(s grpc.ServiceRegistrar, srv QuartzAPIServer) {
	s.RegisterService(&QuartzAPI_ServiceDesc, srv)
}

func _QuartzAPI_GetPredictedTimeseries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPredictedTimeseriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuartzAPIServer).GetPredictedTimeseries(m, &quartzAPIGetPredictedTimeseriesServer{stream})
}

type QuartzAPI_GetPredictedTimeseriesServer interface {
	Send(*GetPredictedTimeseriesResponse) error
	grpc.ServerStream
}

type quartzAPIGetPredictedTimeseriesServer struct {
	grpc.ServerStream
}

func (x *quartzAPIGetPredictedTimeseriesServer) Send(m *GetPredictedTimeseriesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QuartzAPI_GetActualTimeseries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetActualTimeseriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuartzAPIServer).GetActualTimeseries(m, &quartzAPIGetActualTimeseriesServer{stream})
}

type QuartzAPI_GetActualTimeseriesServer interface {
	Send(*GetActualTimeseriesResponse) error
	grpc.ServerStream
}

type quartzAPIGetActualTimeseriesServer struct {
	grpc.ServerStream
}

func (x *quartzAPIGetActualTimeseriesServer) Send(m *GetActualTimeseriesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _QuartzAPI_GetActualCrossSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActualCrossSectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuartzAPIServer).GetActualCrossSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.QuartzAPI/GetActualCrossSection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuartzAPIServer).GetActualCrossSection(ctx, req.(*GetActualCrossSectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuartzAPI_GetPredictedCrossSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPredictedCrossSectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuartzAPIServer).GetPredictedCrossSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.QuartzAPI/GetPredictedCrossSection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuartzAPIServer).GetPredictedCrossSection(ctx, req.(*GetPredictedCrossSectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuartzAPI_GetLocationMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuartzAPIServer).GetLocationMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.QuartzAPI/GetLocationMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuartzAPIServer).GetLocationMetadata(ctx, req.(*GetLocationMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QuartzAPI_ServiceDesc is the grpc.ServiceDesc for QuartzAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QuartzAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.QuartzAPI",
	HandlerType: (*QuartzAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActualCrossSection",
			Handler:    _QuartzAPI_GetActualCrossSection_Handler,
		},
		{
			MethodName: "GetPredictedCrossSection",
			Handler:    _QuartzAPI_GetPredictedCrossSection_Handler,
		},
		{
			MethodName: "GetLocationMetadata",
			Handler:    _QuartzAPI_GetLocationMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetPredictedTimeseries",
			Handler:       _QuartzAPI_GetPredictedTimeseries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetActualTimeseries",
			Handler:       _QuartzAPI_GetActualTimeseries_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "src/proto/api.proto",
}
