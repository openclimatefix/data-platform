# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: fcfsapi/common.proto, fcfsapi/crud.proto, fcfsapi/quartzui.proto, fcfsapi/service.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncGenerator, List, Optional

import betterproto
import grpclib


class EnergySource(betterproto.Enum):
    ENERGY_SOURCE_UNSPECIFIED = 0
    ENERGY_SOURCE_SOLAR = 1
    ENERGY_SOURCE_WIND = 2


@dataclass
class Yield(betterproto.Message):
    yield_kw: int = betterproto.int64_field(1)
    timestamp_unix: int = betterproto.int64_field(2)


@dataclass
class CreateModelRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    make_default: bool = betterproto.bool_field(3)


@dataclass
class CreateModelResponse(betterproto.Message):
    model_id: int = betterproto.int32_field(1)


@dataclass
class Forecast(betterproto.Message):
    model_id: int = betterproto.int32_field(1)
    location_id: int = betterproto.int32_field(2)
    energy_source: "EnergySource" = betterproto.enum_field(3)
    init_time_utc: datetime = betterproto.message_field(4)


@dataclass
class CreateForecastRequest(betterproto.Message):
    forecast: "Forecast" = betterproto.message_field(1)
    predicted_generation_values: List[
        "CreateForecastRequestPredictedGenerationValue"
    ] = betterproto.message_field(2)


@dataclass
class CreateForecastRequestPredictedGenerationValue(betterproto.Message):
    horizon_mins: int = betterproto.int32_field(1)
    p50_pct: float = betterproto.float_field(2)
    p10_pct: float = betterproto.float_field(3)
    p90_pct: float = betterproto.float_field(4)
    metadata: str = betterproto.string_field(5)


@dataclass
class CreateForecastResponse(betterproto.Message):
    forecast_id: int = betterproto.int64_field(1)


@dataclass
class CreateSiteRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    latitude: float = betterproto.float_field(3)
    longitude: float = betterproto.float_field(4)
    capacity_kw: int = betterproto.int64_field(5)
    metadata: str = betterproto.string_field(6)


@dataclass
class CreateGspRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    geometry: str = betterproto.string_field(3)
    capacity_mw: int = betterproto.int64_field(4)
    metadata: str = betterproto.string_field(5)


@dataclass
class CreateLocationResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)


@dataclass
class GetLocationRequest(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)


@dataclass
class GetLocationResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    latitude: float = betterproto.float_field(3)
    longitude: float = betterproto.float_field(4)
    capacity_kw: int = betterproto.int64_field(5)
    metadata: str = betterproto.string_field(6)


@dataclass
class GetLocationsAsGeoJSONRequest(betterproto.Message):
    location_ids: List[int] = betterproto.int32_field(1)
    unsimplified: bool = betterproto.bool_field(2)


@dataclass
class GetLocationsAsGeoJSONResponse(betterproto.Message):
    geojson: str = betterproto.string_field(1)


@dataclass
class CreateObservationsRequest(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    observer_name: str = betterproto.string_field(3)
    yields: List["Yield"] = betterproto.message_field(4)


@dataclass
class CreateObservationsResponse(betterproto.Message):
    pass


@dataclass
class CreateObserverRequest(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass
class CreateObserverResponse(betterproto.Message):
    observer_id: int = betterproto.int32_field(1)


@dataclass
class YieldPrediction(betterproto.Message):
    """
    --- Common Message Types
    ---------------------------------------------------
    """

    yield_kw: int = betterproto.int64_field(1)
    timestamp_unix: int = betterproto.int64_field(2)
    uncertainty: "YieldPredictionUncertainty" = betterproto.message_field(3)


@dataclass
class YieldPredictionUncertainty(betterproto.Message):
    lower_kw: int = betterproto.int64_field(1)
    upper_kw: int = betterproto.int64_field(2)


@dataclass
class YieldDelta(betterproto.Message):
    delta_kw: int = betterproto.sint64_field(1)
    timestamp_unix: int = betterproto.int64_field(2)


@dataclass
class GetPredictedTimeseriesRequest(betterproto.Message):
    location_ids: List[int] = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    # * The desired minimum difference between the forecast initialisation time,
    # and each target time in minutes. A value of 0 gives the most recently
    # predicted values for each target time (default).
    horizon_mins: int = betterproto.int32_field(3)


@dataclass
class GetPredictedTimeseriesResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yields: List["YieldPrediction"] = betterproto.message_field(2)


@dataclass
class GetPredictedTimeseriesDeltasRequest(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    # * The desired difference between the initialisation time and the target
    # time in minutes. 0 gives the most recently predicted deltas, and is the
    # default if not specified.
    horizon_mins: int = betterproto.int32_field(3)
    # * The name of the desired model to fetch predicted yields from. If not
    # specified, the default model will be used.
    model_name: str = betterproto.string_field(4)
    # * The version of the model to fetch predicted yields from. If not
    # specified, the latest version of the named model will be used.
    model_version: str = betterproto.string_field(5)
    # * The name of the provider of observed yields to fetch from. If not
    # specified, the default observer will be used.
    observer_name: str = betterproto.string_field(6)


@dataclass
class GetPredictedTimeseriesDeltasResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    deltas: List["YieldDelta"] = betterproto.message_field(2)


@dataclass
class GetObservedTimeseriesRequest(betterproto.Message):
    location_ids: List[str] = betterproto.string_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)


@dataclass
class GetObservedTimeseriesResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yields: List["Yield"] = betterproto.message_field(2)


@dataclass
class GetPredictedCrossSectionRequest(betterproto.Message):
    location_ids: List[int] = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)
    timestamp_unix: int = betterproto.int64_field(3)


@dataclass
class GetPredictedCrossSectionResponse(betterproto.Message):
    timestamp_unix: int = betterproto.int64_field(1)
    yields_kw: List[int] = betterproto.int64_field(2)


@dataclass
class GetLatestForecastRequest(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    energy_source: "EnergySource" = betterproto.enum_field(2)


@dataclass
class GetLatestForecastResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    forecast_id: int = betterproto.int64_field(2)
    yields: List["YieldPrediction"] = betterproto.message_field(3)


class QuartzAPIStub(betterproto.ServiceStub):
    async def get_predicted_timeseries(
        self,
        *,
        location_ids: List[int] = [],
        energy_source: "EnergySource" = 0,
        horizon_mins: int = 0,
    ) -> AsyncGenerator[GetPredictedTimeseriesResponse, None]:
        request = GetPredictedTimeseriesRequest()
        request.location_ids = location_ids
        request.energy_source = energy_source
        request.horizon_mins = horizon_mins

        async for response in self._unary_stream(
            "/fcfsapi.QuartzAPI/GetPredictedTimeseries",
            request,
            GetPredictedTimeseriesResponse,
        ):
            yield response

    async def get_predicted_timeseries_deltas(
        self,
        *,
        location_id: int = 0,
        energy_source: "EnergySource" = 0,
        horizon_mins: int = 0,
        model_name: str = "",
        model_version: str = "",
        observer_name: str = "",
    ) -> GetPredictedTimeseriesDeltasResponse:
        request = GetPredictedTimeseriesDeltasRequest()
        request.location_id = location_id
        request.energy_source = energy_source
        request.horizon_mins = horizon_mins
        request.model_name = model_name
        request.model_version = model_version
        request.observer_name = observer_name

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetPredictedTimeseriesDeltas",
            request,
            GetPredictedTimeseriesDeltasResponse,
        )

    async def get_predicted_cross_section(
        self,
        *,
        location_ids: List[int] = [],
        energy_source: "EnergySource" = 0,
        timestamp_unix: int = 0,
    ) -> GetPredictedCrossSectionResponse:
        request = GetPredictedCrossSectionRequest()
        request.location_ids = location_ids
        request.energy_source = energy_source
        request.timestamp_unix = timestamp_unix

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetPredictedCrossSection",
            request,
            GetPredictedCrossSectionResponse,
        )

    async def get_observed_timeseries(
        self, *, location_ids: List[str] = [], energy_source: "EnergySource" = 0
    ) -> AsyncGenerator[GetObservedTimeseriesResponse, None]:
        request = GetObservedTimeseriesRequest()
        request.location_ids = location_ids
        request.energy_source = energy_source

        async for response in self._unary_stream(
            "/fcfsapi.QuartzAPI/GetObservedTimeseries",
            request,
            GetObservedTimeseriesResponse,
        ):
            yield response

    async def get_latest_forecast(
        self, *, location_id: int = 0, energy_source: "EnergySource" = 0
    ) -> GetLatestForecastResponse:
        request = GetLatestForecastRequest()
        request.location_id = location_id
        request.energy_source = energy_source

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetLatestForecast",
            request,
            GetLatestForecastResponse,
        )

    async def get_locations_as_geo_j_s_o_n(
        self, *, location_ids: List[int] = [], unsimplified: bool = False
    ) -> GetLocationsAsGeoJSONResponse:
        request = GetLocationsAsGeoJSONRequest()
        request.location_ids = location_ids
        request.unsimplified = unsimplified

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetLocationsAsGeoJSON",
            request,
            GetLocationsAsGeoJSONResponse,
        )

    async def create_site(
        self,
        *,
        name: str = "",
        energy_source: "EnergySource" = 0,
        latitude: float = 0,
        longitude: float = 0,
        capacity_kw: int = 0,
        metadata: str = "",
    ) -> CreateLocationResponse:
        request = CreateSiteRequest()
        request.name = name
        request.energy_source = energy_source
        request.latitude = latitude
        request.longitude = longitude
        request.capacity_kw = capacity_kw
        request.metadata = metadata

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateSite",
            request,
            CreateLocationResponse,
        )

    async def create_gsp(
        self,
        *,
        name: str = "",
        energy_source: "EnergySource" = 0,
        geometry: str = "",
        capacity_mw: int = 0,
        metadata: str = "",
    ) -> CreateLocationResponse:
        request = CreateGspRequest()
        request.name = name
        request.energy_source = energy_source
        request.geometry = geometry
        request.capacity_mw = capacity_mw
        request.metadata = metadata

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateGsp",
            request,
            CreateLocationResponse,
        )

    async def get_location(
        self, *, location_id: int = 0, energy_source: "EnergySource" = 0
    ) -> GetLocationResponse:
        request = GetLocationRequest()
        request.location_id = location_id
        request.energy_source = energy_source

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetLocation",
            request,
            GetLocationResponse,
        )

    async def create_model(
        self, *, name: str = "", version: str = "", make_default: bool = False
    ) -> CreateModelResponse:
        request = CreateModelRequest()
        request.name = name
        request.version = version
        request.make_default = make_default

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateModel",
            request,
            CreateModelResponse,
        )

    async def create_forecast(
        self,
        *,
        forecast: Optional["Forecast"] = None,
        predicted_generation_values: List[
            "CreateForecastRequestPredictedGenerationValue"
        ] = [],
    ) -> CreateForecastResponse:
        request = CreateForecastRequest()
        if forecast is not None:
            request.forecast = forecast
        if predicted_generation_values is not None:
            request.predicted_generation_values = predicted_generation_values

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateForecast",
            request,
            CreateForecastResponse,
        )

    async def create_observer(self, *, name: str = "") -> CreateObserverResponse:
        request = CreateObserverRequest()
        request.name = name

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateObserver",
            request,
            CreateObserverResponse,
        )

    async def create_observations(
        self,
        *,
        location_id: int = 0,
        energy_source: "EnergySource" = 0,
        observer_name: str = "",
        yields: List["Yield"] = [],
    ) -> CreateObservationsResponse:
        request = CreateObservationsRequest()
        request.location_id = location_id
        request.energy_source = energy_source
        request.observer_name = observer_name
        if yields is not None:
            request.yields = yields

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateObservations",
            request,
            CreateObservationsResponse,
        )
