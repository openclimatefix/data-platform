# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: fcfsapi/forecast.proto, fcfsapi/location.proto, fcfsapi/quartzui.proto, fcfsapi/service.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncGenerator, List, Optional

import betterproto
import grpclib


@dataclass
class CreateModelRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    make_default: bool = betterproto.bool_field(3)


@dataclass
class CreateModelResponse(betterproto.Message):
    model_id: int = betterproto.int32_field(1)


@dataclass
class PredictedGenerationValue(betterproto.Message):
    horizon_mins: int = betterproto.int32_field(1)
    p50: int = betterproto.int32_field(2)
    p10: int = betterproto.int32_field(3)
    p90: int = betterproto.int32_field(4)
    metadata: str = betterproto.string_field(5)


@dataclass
class Forecast(betterproto.Message):
    model_id: int = betterproto.int32_field(1)
    location_id: int = betterproto.int32_field(2)
    init_time_utc: datetime = betterproto.message_field(3)


@dataclass
class CreateForecastRequest(betterproto.Message):
    forecast: "Forecast" = betterproto.message_field(1)
    predicted_generation_values: List["PredictedGenerationValue"] = (
        betterproto.message_field(2)
    )


@dataclass
class CreateForecastResponse(betterproto.Message):
    forecast_id: int = betterproto.int64_field(1)


@dataclass
class CreateSiteRequest(betterproto.Message):
    """
    --- Locations
    ----------------------------------------------------------------
    """

    name: str = betterproto.string_field(1)
    latitude: float = betterproto.float_field(2)
    longitude: float = betterproto.float_field(3)
    capacity_kw: int = betterproto.int64_field(4)
    metadata: str = betterproto.string_field(5)


@dataclass
class CreateGspRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    geometry: str = betterproto.string_field(2)
    capacity_mw: int = betterproto.int64_field(3)
    metadata: str = betterproto.string_field(4)


@dataclass
class CreateLocationResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)


@dataclass
class GetLocationRequest(betterproto.Message):
    location_id: int = betterproto.int32_field(1)


@dataclass
class GetLocationResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    latitude: float = betterproto.float_field(3)
    longitude: float = betterproto.float_field(4)
    capacity_kw: int = betterproto.int64_field(5)
    metadata: str = betterproto.string_field(6)


@dataclass
class GetLocationsAsGeoJSONRequest(betterproto.Message):
    location_ids: List[int] = betterproto.int32_field(1)
    unsimplified: bool = betterproto.bool_field(2)


@dataclass
class GetLocationsAsGeoJSONResponse(betterproto.Message):
    geojson: str = betterproto.string_field(1)


@dataclass
class GetPredictedTimeseriesRequest(betterproto.Message):
    """
    --- GetPredictedTimeseries
    --------------------------------------------------------
    """

    location_ids: List[int] = betterproto.int32_field(1)


@dataclass
class GetPredictedTimeseriesResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yields: List["PredictedYield"] = betterproto.message_field(2)


@dataclass
class PredictedYield(betterproto.Message):
    yield_kw: int = betterproto.int32_field(1)
    timestamp_unix: int = betterproto.int64_field(2)
    uncertainty: "PredictedYieldUncertainty" = betterproto.message_field(3)


@dataclass
class PredictedYieldUncertainty(betterproto.Message):
    lower_kw: int = betterproto.int32_field(1)
    upper_kw: int = betterproto.int32_field(2)


@dataclass
class GetActualTimeseriesRequest(betterproto.Message):
    """
    --- GetActualTimeseries
    -----------------------------------------------------------
    """

    location_ids: List[str] = betterproto.string_field(1)


@dataclass
class GetActualTimeseriesResponse(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yields: List["ActualYield"] = betterproto.message_field(2)


@dataclass
class ActualYield(betterproto.Message):
    yield_kw: int = betterproto.int32_field(1)
    timestamp_unix: int = betterproto.int64_field(2)


@dataclass
class GetPredictedCrossSectionRequest(betterproto.Message):
    """
    --- GetPredictedCrossSection
    ------------------------------------------------------
    """

    location_ids: List[int] = betterproto.int32_field(1)
    timestamp_unix: int = betterproto.int64_field(2)


@dataclass
class GetPredictedCrossSectionResponse(betterproto.Message):
    timestamp_unix: int = betterproto.int64_field(1)
    yields: List["PredictedYieldAtLocation"] = betterproto.message_field(2)


@dataclass
class PredictedYieldAtLocation(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yield_kw: int = betterproto.int32_field(2)
    uncertainty: "PredictedYieldUncertainty" = betterproto.message_field(3)


@dataclass
class GetActualCrossSectionRequest(betterproto.Message):
    """
    --- GetActualCrossSection
    ---------------------------------------------------------
    """

    location_ids: List[int] = betterproto.int32_field(1)
    timestamp_unix: int = betterproto.int64_field(2)


@dataclass
class GetActualCrossSectionResponse(betterproto.Message):
    timestamp_unix: int = betterproto.int64_field(1)
    yields: List["ActualYieldAtLocation"] = betterproto.message_field(2)


@dataclass
class ActualYieldAtLocation(betterproto.Message):
    location_id: int = betterproto.int32_field(1)
    yield_kw: int = betterproto.int32_field(2)


class QuartzAPIStub(betterproto.ServiceStub):
    async def get_predicted_timeseries(
        self, *, location_ids: List[int] = []
    ) -> AsyncGenerator[GetPredictedTimeseriesResponse, None]:
        request = GetPredictedTimeseriesRequest()
        request.location_ids = location_ids

        async for response in self._unary_stream(
            "/fcfsapi.QuartzAPI/GetPredictedTimeseries",
            request,
            GetPredictedTimeseriesResponse,
        ):
            yield response

    async def get_actual_timeseries(
        self, *, location_ids: List[str] = []
    ) -> AsyncGenerator[GetActualTimeseriesResponse, None]:
        request = GetActualTimeseriesRequest()
        request.location_ids = location_ids

        async for response in self._unary_stream(
            "/fcfsapi.QuartzAPI/GetActualTimeseries",
            request,
            GetActualTimeseriesResponse,
        ):
            yield response

    async def get_actual_cross_section(
        self, *, location_ids: List[int] = [], timestamp_unix: int = 0
    ) -> GetActualCrossSectionResponse:
        request = GetActualCrossSectionRequest()
        request.location_ids = location_ids
        request.timestamp_unix = timestamp_unix

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetActualCrossSection",
            request,
            GetActualCrossSectionResponse,
        )

    async def get_predicted_cross_section(
        self, *, location_ids: List[int] = [], timestamp_unix: int = 0
    ) -> GetPredictedCrossSectionResponse:
        request = GetPredictedCrossSectionRequest()
        request.location_ids = location_ids
        request.timestamp_unix = timestamp_unix

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetPredictedCrossSection",
            request,
            GetPredictedCrossSectionResponse,
        )

    async def create_solar_site(
        self,
        *,
        name: str = "",
        latitude: float = 0,
        longitude: float = 0,
        capacity_kw: int = 0,
        metadata: str = "",
    ) -> CreateLocationResponse:
        request = CreateSiteRequest()
        request.name = name
        request.latitude = latitude
        request.longitude = longitude
        request.capacity_kw = capacity_kw
        request.metadata = metadata

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateSolarSite",
            request,
            CreateLocationResponse,
        )

    async def create_solar_gsp(
        self,
        *,
        name: str = "",
        geometry: str = "",
        capacity_mw: int = 0,
        metadata: str = "",
    ) -> CreateLocationResponse:
        request = CreateGspRequest()
        request.name = name
        request.geometry = geometry
        request.capacity_mw = capacity_mw
        request.metadata = metadata

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateSolarGsp",
            request,
            CreateLocationResponse,
        )

    async def get_solar_location(self, *, location_id: int = 0) -> GetLocationResponse:
        request = GetLocationRequest()
        request.location_id = location_id

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetSolarLocation",
            request,
            GetLocationResponse,
        )

    async def get_locations_as_geo_j_s_o_n(
        self, *, location_ids: List[int] = [], unsimplified: bool = False
    ) -> GetLocationsAsGeoJSONResponse:
        request = GetLocationsAsGeoJSONRequest()
        request.location_ids = location_ids
        request.unsimplified = unsimplified

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/GetLocationsAsGeoJSON",
            request,
            GetLocationsAsGeoJSONResponse,
        )

    async def create_model(
        self, *, name: str = "", version: str = "", make_default: bool = False
    ) -> CreateModelResponse:
        request = CreateModelRequest()
        request.name = name
        request.version = version
        request.make_default = make_default

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateModel",
            request,
            CreateModelResponse,
        )

    async def create_solar_forecast(
        self,
        *,
        forecast: Optional["Forecast"] = None,
        predicted_generation_values: List["PredictedGenerationValue"] = [],
    ) -> CreateForecastResponse:
        request = CreateForecastRequest()
        if forecast is not None:
            request.forecast = forecast
        if predicted_generation_values is not None:
            request.predicted_generation_values = predicted_generation_values

        return await self._unary_unary(
            "/fcfsapi.QuartzAPI/CreateSolarForecast",
            request,
            CreateForecastResponse,
        )
