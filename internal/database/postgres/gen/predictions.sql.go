// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: predictions.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createForecast = `-- name: CreateForecast :one

INSERT INTO pred.forecasts(
    location_id, source_type_id, predictor_id, init_time_utc
) VALUES (
    $1, $2, $3, $4
) RETURNING forecast_id, init_time_utc, source_type_id, location_id, predictor_id
`

type CreateForecastParams struct {
	LocationID   int32
	SourceTypeID int16
	PredictorID  int32
	InitTimeUtc  pgtype.Timestamp
}

type CreateForecastRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	PredictorID  int32
}

// --- Forecasts ------------------------------------------------------------------------------
func (q *Queries) CreateForecast(ctx context.Context, arg CreateForecastParams) (CreateForecastRow, error) {
	row := q.db.QueryRow(ctx, createForecast,
		arg.LocationID,
		arg.SourceTypeID,
		arg.PredictorID,
		arg.InitTimeUtc,
	)
	var i CreateForecastRow
	err := row.Scan(
		&i.ForecastID,
		&i.InitTimeUtc,
		&i.SourceTypeID,
		&i.LocationID,
		&i.PredictorID,
	)
	return i, err
}

type CreatePredictionsAsInt16UsingCopyParams struct {
	HorizonMins   int16
	P10Sip        *int16
	P50Sip        int16
	P90Sip        *int16
	ForecastID    int32
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

const createPredictor = `-- name: CreatePredictor :one

INSERT INTO pred.predictors (predictor_name, predictor_version) VALUES (
    $1, $2
) RETURNING predictor_id
`

type CreatePredictorParams struct {
	PredictorName    string
	PredictorVersion string
}

// --- Predictor ------------------------------------------------------------------------------
func (q *Queries) CreatePredictor(ctx context.Context, arg CreatePredictorParams) (int32, error) {
	row := q.db.QueryRow(ctx, createPredictor, arg.PredictorName, arg.PredictorVersion)
	var predictor_id int32
	err := row.Scan(&predictor_id)
	return predictor_id, err
}

const getLatestForecastAtHorizonSincePivot = `-- name: GetLatestForecastAtHorizonSincePivot :one
/* GetLatestForecastAtHorizonSincePivot retrieves the latest forecast for a given location,
 * source type, and predictor. Only forecasts that are older than the pivot time
 * minus the specified horizon are considered.
 */
SELECT
    f.forecast_id,
    f.init_time_utc,
    f.source_type_id,
    f.location_id,
    f.predictor_id
FROM pred.forecasts f
WHERE f.location_id = $1
AND f.source_type_id = $2
AND f.predictor_id = $3
AND f.init_time_utc <= $4::timestamp - MAKE_INTERVAL(mins => $5::integer)
ORDER BY f.init_time_utc DESC
LIMIT 1
`

type GetLatestForecastAtHorizonSincePivotParams struct {
	LocationID     int32
	SourceTypeID   int16
	PredictorID    int32
	PivotTimestamp pgtype.Timestamp
	HorizonMins    int32
}

type GetLatestForecastAtHorizonSincePivotRow struct {
	ForecastID   int32
	InitTimeUtc  pgtype.Timestamp
	SourceTypeID int16
	LocationID   int32
	PredictorID  int32
}

func (q *Queries) GetLatestForecastAtHorizonSincePivot(ctx context.Context, arg GetLatestForecastAtHorizonSincePivotParams) (GetLatestForecastAtHorizonSincePivotRow, error) {
	row := q.db.QueryRow(ctx, getLatestForecastAtHorizonSincePivot,
		arg.LocationID,
		arg.SourceTypeID,
		arg.PredictorID,
		arg.PivotTimestamp,
		arg.HorizonMins,
	)
	var i GetLatestForecastAtHorizonSincePivotRow
	err := row.Scan(
		&i.ForecastID,
		&i.InitTimeUtc,
		&i.SourceTypeID,
		&i.LocationID,
		&i.PredictorID,
	)
	return i, err
}

const getPredictorElseLatest = `-- name: GetPredictorElseLatest :one
/* GetPredictor retrieves a predictor by its name and version.
 * If no version is provided (empty string), it defaults to the latest version
 * for the given predictor name.
*/
SELECT
    predictor_id, predictor_name, predictor_version, created_at_utc
FROM pred.predictors
WHERE 
    predictor_name = $1::text
    AND predictor_version = COALESCE(
        NULLIF($2::text, ''),
        (
            SELECT p.predictor_version
            FROM pred.predictors p
            WHERE p.predictor_name = $1::text
            ORDER BY p.created_at_utc DESC
            LIMIT 1
        )
    )
`

type GetPredictorElseLatestParams struct {
	PredictorName    string
	PredictorVersion string
}

func (q *Queries) GetPredictorElseLatest(ctx context.Context, arg GetPredictorElseLatestParams) (PredPredictor, error) {
	row := q.db.QueryRow(ctx, getPredictorElseLatest, arg.PredictorName, arg.PredictorVersion)
	var i PredPredictor
	err := row.Scan(
		&i.PredictorID,
		&i.PredictorName,
		&i.PredictorVersion,
		&i.CreatedAtUtc,
	)
	return i, err
}

const getWeekAverageDeltasForLocations = `-- name: GetWeekAverageDeltasForLocations :many
/* GetWeekAverageDeltasForLocations retrieves the average deltas between predicted and observed generation values
 * for a given source type, predictor, and observer, across a week of forecasts made with the same init time.
 * The pivot timestamp is used to determine the week and init time of interest.
 * The results are grouped by location and horizon.
 */
WITH desired_init_times AS (
    SELECT 
        (d.day::date + $4::timestamp::time)::timestamp AS init_time_utc 
    FROM generate_series(
        $4::timestamp::date - INTERVAL '7 days',
        $4::timestamp::date - INTERVAL '1 day',
        INTERVAL '1 day'
    ) AS d(day)
    ORDER BY d.day ASC
),
relevant_forecasts AS (
    SELECT 
        f.forecast_id,
        f.init_time_utc,
        f.source_type_id,
        f.location_id,
        f.predictor_id
    FROM pred.forecasts f
    INNER JOIN desired_init_times dit ON f.init_time_utc = dit.init_time_utc
    WHERE f.location_id = ANY($5::integer[])
    AND f.source_type_id = $1
    AND f.predictor_id = $2
),
predicted_values AS (
    SELECT
        rf.location_id,
        rf.forecast_id,
        rf.source_type_id,
        pgv.target_time_utc,
        pgv.horizon_mins,
        pgv.p50_sip
    FROM relevant_forecasts rf
    INNER JOIN pred.predicted_generation_values pgv USING (forecast_id)
),
deltas AS (
    SELECT
        pv.location_id,
        pv.source_type_id,
        pv.forecast_id,
        pv.target_time_utc,
        pv.horizon_mins,
        pv.p50_sip - ov.value_sip AS delta_sip
    FROM predicted_values pv
    LEFT JOIN obs.observed_generation_values ov USING (location_id, source_type_id)
    WHERE
        ov.observer_id = $3
        AND ov.observation_time_utc = pv.target_time_utc
)
SELECT
    d.location_id,
    d.horizon_mins,
    AVG(d.delta_sip) AS avg_delta_sip
FROM deltas d
GROUP BY d.location_id, d.horizon_mins
ORDER BY d.location_id, d.horizon_mins
`

type GetWeekAverageDeltasForLocationsParams struct {
	SourceTypeID   int16
	PredictorID    int32
	ObserverID     int32
	PivotTimestamp pgtype.Timestamp
	LocationIds    []int32
}

type GetWeekAverageDeltasForLocationsRow struct {
	LocationID  int32
	HorizonMins int16
	AvgDeltaSip float64
}

func (q *Queries) GetWeekAverageDeltasForLocations(ctx context.Context, arg GetWeekAverageDeltasForLocationsParams) ([]GetWeekAverageDeltasForLocationsRow, error) {
	rows, err := q.db.Query(ctx, getWeekAverageDeltasForLocations,
		arg.SourceTypeID,
		arg.PredictorID,
		arg.ObserverID,
		arg.PivotTimestamp,
		arg.LocationIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeekAverageDeltasForLocationsRow{}
	for rows.Next() {
		var i GetWeekAverageDeltasForLocationsRow
		if err := rows.Scan(&i.LocationID, &i.HorizonMins, &i.AvgDeltaSip); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPredictionsAtTimeForLocations = `-- name: ListPredictionsAtTimeForLocations :many
/* ListPredictionsAtTimeForLocations retrieves predicted generation values as percentages
 * of capacity for a specific time and horizon.
 * This is useful for comparing predictions across multiple locations.
 * Predicted values are 16-bit integers, with 0 representing 0% and 30000 representing 100% of capacity.
 */
WITH relevant_forecasts AS (
    SELECT
        f.forecast_id,
        f.location_id,
        f.init_time_utc,
        ROW_NUMBER() OVER (PARTITION BY f.location_id ORDER BY f.init_time_utc DESC) AS rn
    FROM pred.forecasts f
    WHERE f.location_id = ANY($4::integer[])
    AND f.source_type_id = $1
    AND f.predictor_id = $2
    AND f.init_time_utc <= $5::timestamp - MAKE_INTERVAL(mins => $3::integer)
),
latest_relevant_forecasts AS (
    SELECT
        rf.forecast_id,
        rf.location_id,
        rf.init_time_utc
    FROM relevant_forecasts rf
    WHERE rf.rn = 1
)
SELECT
    rf.location_id,
    pgv.horizon_mins,
    pgv.p10_sip,
    pgv.p50_sip,
    pgv.p90_sip,
    pgv.target_time_utc,
    pgv.metadata
FROM pred.predicted_generation_values pgv
INNER JOIN latest_relevant_forecasts rf USING (forecast_id)
WHERE pgv.horizon_mins = $3::integer
`

type ListPredictionsAtTimeForLocationsParams struct {
	SourceTypeID int16
	PredictorID  int32
	HorizonMins  int32
	LocationIds  []int32
	Time         pgtype.Timestamp
}

type ListPredictionsAtTimeForLocationsRow struct {
	LocationID    int32
	HorizonMins   int16
	P10Sip        *int16
	P50Sip        int16
	P90Sip        *int16
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

func (q *Queries) ListPredictionsAtTimeForLocations(ctx context.Context, arg ListPredictionsAtTimeForLocationsParams) ([]ListPredictionsAtTimeForLocationsRow, error) {
	rows, err := q.db.Query(ctx, listPredictionsAtTimeForLocations,
		arg.SourceTypeID,
		arg.PredictorID,
		arg.HorizonMins,
		arg.LocationIds,
		arg.Time,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPredictionsAtTimeForLocationsRow{}
	for rows.Next() {
		var i ListPredictionsAtTimeForLocationsRow
		if err := rows.Scan(
			&i.LocationID,
			&i.HorizonMins,
			&i.P10Sip,
			&i.P50Sip,
			&i.P90Sip,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPredictionsForForecast = `-- name: ListPredictionsForForecast :many
/* ListPredictionsForForecast retrieves predicted generation values
 * for a given forecast as smallint percentages (sip) of capacity;
 * with 0 representing 0% and 30000 representing 100% of capacity.
 */
SELECT
    horizon_mins,
    p10_sip,
    p50_sip,
    p90_sip,
    target_time_utc,
    metadata
FROM pred.predicted_generation_values
WHERE forecast_id = $1
`

type ListPredictionsForForecastRow struct {
	HorizonMins   int16
	P10Sip        *int16
	P50Sip        int16
	P90Sip        *int16
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

func (q *Queries) ListPredictionsForForecast(ctx context.Context, forecastID int32) ([]ListPredictionsForForecastRow, error) {
	rows, err := q.db.Query(ctx, listPredictionsForForecast, forecastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPredictionsForForecastRow{}
	for rows.Next() {
		var i ListPredictionsForForecastRow
		if err := rows.Scan(
			&i.HorizonMins,
			&i.P10Sip,
			&i.P50Sip,
			&i.P90Sip,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPredictionsForLocation = `-- name: ListPredictionsForLocation :many
/* ListPredictionsForLocation retrieves predicted generation values as a timeseries.
 * Multiple overlapping forecasts can make up the timeseries, so predictions with the same target time
 * are filtered by lowest allowable horizon (i.e. predicted closest to their target time).
 * Predicted values are smallint percentages (sip) of capcity;
 * with 0 representing 0% and 30000 representing 100% of capacity.
 */
WITH relevant_forecasts AS (
    /* Get all the forecasts that fall within the time window for the given location, source, and predictor */
    SELECT
        f.forecast_id
    FROM pred.forecasts f
    WHERE f.location_id = $1
    AND f.source_type_id = $2
    AND f.predictor_id = $3
    AND f.init_time_utc BETWEEN
        $4::timestamp - MAKE_INTERVAL(mins => $5::integer)
        AND $6::timestamp
),
filteredPredictions AS (
    /* Get all the predicted generation values for the relevant forecasts who's horizon is greater than
     * or equal to the specified horizon_mins */
    SELECT
        pv.horizon_mins,
        pv.p10_sip,
        pv.p50_sip,
        pv.p90_sip,
        pv.target_time_utc,
        pv.metadata
    FROM pred.predicted_generation_values pv
    INNER JOIN relevant_forecasts rf USING (forecast_id)
    WHERE pv.target_time_utc BETWEEN
        $4::timestamp - MAKE_INTERVAL(mins => $5::integer)
        AND $6::timestamp
    AND pv.horizon_mins >= $5::integer
),
rankedPredictions AS (
    /* Rank the predictions by horizon_mins for each target_time_utc */
    SELECT
        horizon_mins, p10_sip, p50_sip, p90_sip, target_time_utc, metadata,
        ROW_NUMBER() OVER (PARTITION BY target_time_utc ORDER BY horizon_mins ASC) AS rn
    FROM filteredPredictions
)
SELECT
    /* For each target time, choose the value with the lowest available horizon */
    rp.horizon_mins,
    p10_sip,
    p50_sip,
    p90_sip,
    rp.target_time_utc,
    rp.metadata
FROM rankedPredictions rp
WHERE rp.rn = 1
ORDER BY rp.target_time_utc ASC
`

type ListPredictionsForLocationParams struct {
	LocationID     int32
	SourceTypeID   int16
	PredictorID    int32
	StartTimestamp pgtype.Timestamp
	HorizonMins    int32
	EndTimestamp   pgtype.Timestamp
}

type ListPredictionsForLocationRow struct {
	HorizonMins   int16
	P10Sip        *int16
	P50Sip        int16
	P90Sip        *int16
	TargetTimeUtc pgtype.Timestamp
	Metadata      []byte
}

func (q *Queries) ListPredictionsForLocation(ctx context.Context, arg ListPredictionsForLocationParams) ([]ListPredictionsForLocationRow, error) {
	rows, err := q.db.Query(ctx, listPredictionsForLocation,
		arg.LocationID,
		arg.SourceTypeID,
		arg.PredictorID,
		arg.StartTimestamp,
		arg.HorizonMins,
		arg.EndTimestamp,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPredictionsForLocationRow{}
	for rows.Next() {
		var i ListPredictionsForLocationRow
		if err := rows.Scan(
			&i.HorizonMins,
			&i.P10Sip,
			&i.P50Sip,
			&i.P90Sip,
			&i.TargetTimeUtc,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPredictors = `-- name: ListPredictors :many
SELECT
    predictor_id, predictor_name, predictor_version, created_at_utc
FROM pred.predictors
ORDER BY created_at_utc DESC
`

func (q *Queries) ListPredictors(ctx context.Context) ([]PredPredictor, error) {
	rows, err := q.db.Query(ctx, listPredictors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PredPredictor{}
	for rows.Next() {
		var i PredPredictor
		if err := rows.Scan(
			&i.PredictorID,
			&i.PredictorName,
			&i.PredictorVersion,
			&i.CreatedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
