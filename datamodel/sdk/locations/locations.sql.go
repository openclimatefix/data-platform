// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: locations.sql

package locations

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocationRegion = `-- name: CreateLocationRegion :one
WITH
    region_subtype AS (
        SELECT id FROM loc.location_subtypes WHERE subtype = 'region'
    ),
    new_loc_id AS (
        INSERT INTO loc.locations (
            name, latitude, longitude, capacity_kw, location_type
        ) VALUES (
            $1, $2, $3, $4, region_subtype
        ) RETURNING id
    )
INSERT INTO loc.region_metadata (
    location_id, created_utc, region_name, boundary_geojson
) VALUES (
    new_loc_id, $5, $6, $7
) RETURNING location_id, id AS region_id
`

type CreateLocationRegionParams struct {
	Name            string
	Latitude        float32
	Longitude       float32
	CapacityKw      int32
	CreatedUtc      pgtype.Timestamp
	RegionName      string
	BoundaryGeojson []byte
}

type CreateLocationRegionRow struct {
	LocationID int32
	RegionID   int32
}

// CreateLocationRegion
//
//	WITH
//	    region_subtype AS (
//	        SELECT id FROM loc.location_subtypes WHERE subtype = 'region'
//	    ),
//	    new_loc_id AS (
//	        INSERT INTO loc.locations (
//	            name, latitude, longitude, capacity_kw, location_type
//	        ) VALUES (
//	            $1, $2, $3, $4, region_subtype
//	        ) RETURNING id
//	    )
//	INSERT INTO loc.region_metadata (
//	    location_id, created_utc, region_name, boundary_geojson
//	) VALUES (
//	    new_loc_id, $5, $6, $7
//	) RETURNING location_id, id AS region_id
func (q *Queries) CreateLocationRegion(ctx context.Context, arg CreateLocationRegionParams) (CreateLocationRegionRow, error) {
	row := q.db.QueryRow(ctx, createLocationRegion,
		arg.Name,
		arg.Latitude,
		arg.Longitude,
		arg.CapacityKw,
		arg.CreatedUtc,
		arg.RegionName,
		arg.BoundaryGeojson,
	)
	var i CreateLocationRegionRow
	err := row.Scan(&i.LocationID, &i.RegionID)
	return i, err
}

const createLocationSite = `-- name: CreateLocationSite :one
WITH 
    site_subtype AS (
        SELECT id FROM loc.location_subtypes WHERE subtype = 'site'
    ),
    new_loc_id AS (
        INSERT INTO loc.locations (
            name, latitude, longitude, capacity_kw, location_type
        ) VALUES (
            $1, $2, $3, $4, site_subtype
        ) RETURNING id
    )
INSERT INTO loc.site_metadata (
    location_id, client_name, client_site_id, yaw_degrees, pitch_degrees, energy_source
) VALUES (
    new_loc_id, $5, $6, $7, $8, $9
) RETURNING location_id, id AS site_id
`

type CreateLocationSiteParams struct {
	Name         string
	Latitude     float32
	Longitude    float32
	CapacityKw   int32
	ClientName   string
	ClientSiteID string
	YawDegrees   *int16
	PitchDegrees *int16
	EnergySource int16
}

type CreateLocationSiteRow struct {
	LocationID int32
	SiteID     int32
}

// CreateLocationSite
//
//	WITH
//	    site_subtype AS (
//	        SELECT id FROM loc.location_subtypes WHERE subtype = 'site'
//	    ),
//	    new_loc_id AS (
//	        INSERT INTO loc.locations (
//	            name, latitude, longitude, capacity_kw, location_type
//	        ) VALUES (
//	            $1, $2, $3, $4, site_subtype
//	        ) RETURNING id
//	    )
//	INSERT INTO loc.site_metadata (
//	    location_id, client_name, client_site_id, yaw_degrees, pitch_degrees, energy_source
//	) VALUES (
//	    new_loc_id, $5, $6, $7, $8, $9
//	) RETURNING location_id, id AS site_id
func (q *Queries) CreateLocationSite(ctx context.Context, arg CreateLocationSiteParams) (CreateLocationSiteRow, error) {
	row := q.db.QueryRow(ctx, createLocationSite,
		arg.Name,
		arg.Latitude,
		arg.Longitude,
		arg.CapacityKw,
		arg.ClientName,
		arg.ClientSiteID,
		arg.YawDegrees,
		arg.PitchDegrees,
		arg.EnergySource,
	)
	var i CreateLocationSiteRow
	err := row.Scan(&i.LocationID, &i.SiteID)
	return i, err
}
